use std::{env, error::Error, fs, path::Path};

use serde::Deserialize;

fn main() -> Result<(), Box<dyn Error>> {
    embuild::espidf::sysenv::output();
    generate_pins_config()?;
    Ok(())
}

#[derive(Debug, Deserialize)]
struct PinConfig {
    led: u8,
    button: u8,
}

fn generate_pins_config() -> Result<(), Box<dyn Error>> {
    // デフォルト値（従来のハードコードと同じ）
    let default = PinConfig {
        led: 12,
        button: 14,
    };

    let config_path = Path::new("config/pins.json");
    let cfg: PinConfig = match fs::read_to_string(config_path) {
        Ok(data) => serde_json::from_str(&data)?,
        Err(_) => default,
    };

    // サポートするピンを制限し、安全に型を生成
    fn pin_type(num: u8) -> Result<&'static str, Box<dyn Error>> {
        match num {
            2 => Ok("esp_idf_hal::gpio::Gpio2"),
            4 => Ok("esp_idf_hal::gpio::Gpio4"),
            5 => Ok("esp_idf_hal::gpio::Gpio5"),
            12 => Ok("esp_idf_hal::gpio::Gpio12"),
            13 => Ok("esp_idf_hal::gpio::Gpio13"),
            14 => Ok("esp_idf_hal::gpio::Gpio14"),
            15 => Ok("esp_idf_hal::gpio::Gpio15"),
            _ => Err(format!("unsupported pin number: {num}").into()),
        }
    }

    let led_ty = pin_type(cfg.led)?;
    let button_ty = pin_type(cfg.button)?;

    let code = format!(
        "// Auto-generated by build.rs. Do not edit manually.\n\n\
         pub type LedPinType = {led};\n\
         pub type ButtonPinType = {button};\n\
         pub fn split_pins(peripherals: esp_idf_hal::peripherals::Peripherals) -> (LedPinType, ButtonPinType) {{\n\
             let pins = peripherals.pins;\n\
             (pins.{led_field}, pins.{button_field})\n\
         }}\n",
        led = led_ty,
        button = button_ty,
        led_field = format!("gpio{}", cfg.led),
        button_field = format!("gpio{}", cfg.button),
    );

    let out_dir = env::var("OUT_DIR")?;
    fs::write(Path::new(&out_dir).join("pins_gen.rs"), code)?;

    // コンフィグが変わったらリビルド
    println!("cargo:rerun-if-changed=config/pins.json");
    Ok(())
}
